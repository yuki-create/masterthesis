・差分
repeat, N,sigma_k,mu_k,sigma_g,mu_gをコマンドライン引数として受け取る。
諸々の初期化の実装完了
updateInput, updateNarmaの動作確認
rk4の動作確認
そもそものばねの長さの変位が10^(-8)程度。
10^(-8)の初期値誤差でようやくばねの長さの波形に反映される。
T,W_inなどによってちょうど良い初期値誤差を見極める。
一連のプログラムが完成。
次は出力を整備する。

・バグ
rk4()で、初期値をずらさないx,yの変異が、ほぼ直線。外力という入力方法はよくないのか？
！座標がアレでも長さは振動しているかもしれない。
！実装は正しそうなので、とりあえずこのまま。
！やはりばねの長さも全く変異なし、おかしい！
>T_input=1では、外力の変化を反映し切れていなかった
lyapunov指数の計算がまだ正常でない。以前のプログラムでは計算ができている。
>initial_d=0.0になっていた。
T_input=10だと、NARMA20が発散する。
lの変位が小さすぎて、W＿outが大きくなる。スケーリングが必要。
自然長が1.0あるので、バイアスも必要では。

----
N=9
const double dt = 0.0025;
const int T_input = 10; // adjust frequency of input signal
const double natu_l = 1.0;
double w_in[] = {1.0};
int fixed_p[] = {4}; // index array of fixed points
int in_p[] = {N-1}; // index array of input points
誤差10^{-8}
----
ちょうど良さそう。
！初期値をずらさない方では10^{-9}程度の変異しか生まれない。
！初期値を導入しなくても結果が変わっていない。2つの系で全く同じ運動をしないとおかしい
！rk4で、_dの系は計算されているがオリジナルの系で更新されていない
！そもそも入力も与えていないのに振動する_d系。
rk4のみとgetSpringLengthをやるときで振動が異なる。

getSpringLengthのみでは変異は発生しない。
!rk4に問題あり。
！！原因は、l_d[N]と配列の要素数を間違えて宣言していたことだった

計算結果を配列に格納するものは配列を引数で渡してvoid関数
計算結果を変数に代入するものはdoubleで返す関数（値渡しなので）
